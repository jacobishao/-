#include<iostream>
#include<string.h>
#include<queue>
using namespace std;
#define N 1000000007
struct point;
int n,m,k;
//dp[i][j][k][l]代表第i+1行,第j+1列,持有k个宝物,且最大值为k-1的方案数.
long long dp[50][50][13][13];
int map[50][50];
queue<point> q;
struct point{
  int x;
  int y;
};

int setdp(int i,int j, int k, int l, long long value)
{
  dp[i-1][j-1][k][l+1]=value;
  return 0;
}
long long getdp(int i,int j,int k, int l)
{
  return dp[i-1][j-1][k][l+1];
}


void initmap()
{
  for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
   	cin>>map[i][j];

}
void initdp11()
{
  setdp(1,1,0,-1,1);
  setdp(1,1,1,map[0][0],1);
 
  if(2<=n&&1<=m){ point e; e.x=2;e.y=1;q.push(e);}
  if(1<=n&&2<=m){ point e; e.x=1;e.y=2;q.push(e);}
}

int main()
{
  cin>>n>>m>>k;
  
  memset(dp, -1, sizeof(dp));

  initmap();
  //point p={.x=1,.y=2};
  initdp11();
  //q.push(p);
 

  while(!q.empty())
  {
    point e= q.front();
    //计算第e.x行 ,第e.y列 手持宝贝为i个  且最大值为j的方案数
    for(int i=0;i<13;i++)
      for(int j=-1;j<13;j++)
	{
	  long long t=0;
	  if(map[e.x-1][e.y-1]<=j)//访点的值不比j小
	    {
	      if(e.x-1>=1) t=(t+getdp(e.x-1,e.y,i,j))%N;
	      if(e.y-1>=1) t=(t+getdp(e.x,e.y-1,i,j))%N;
	      setdp(e.x, e.y, i, j, t);
	    }
	  else
	    {
	      if(e.x-1>=1&&i-1>=0) t=(t+getdp(e.x-1,e.y,i-1,j))%N;
	      if(e.y-1>=1&&i-1>=0) t+=(t+getdp(e.x,e.y-1,i-1,j))%N;
	      setdp(e.x, e.y, i, j, t);

	      t=0;
	      if(e.x-1>=1&&i-1>=-1) //向上拿
		{
		  for(int z=-1;z<map[e.x-1][e.y-1];z++)
		    t=(t+getdp(e.x-1,e.y,i-1,z))%N;
		}
	      if(e.y-1>=1&&i-1>=-1) //向左拿
		 {
		  for(int z=-1;z<map[e.x-1][e.y-1];z++)
		    t=(t+getdp(e.x,e.y-1,i-1,z))%N;
		}
	      setdp(e.x,e.y,i,map[e.x-1][e.y-1],t);
	    }
	  
	  //setdp(e.x,e.y,i,
	}

    
    q.pop();
    if(e.x+1<=n) { point po; po.x=e.x+1;po.y=e.y; q.push(po);}
    if(e.y+1<=m) { point po; po.x=e.x;po.y=e.y+1; q.push(po);}
    

  }
  
  long long sum;
  for(int z=-1;z<13;z++)
    sum+=getdp(n,m,k,z);

  cout<<sum<<endl;
  
  
  


  return 0;
}
